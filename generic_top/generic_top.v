
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module generic_top(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,

	//////////// LED //////////
	output		     [8:0]		LEDG,
	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
	output		     [6:0]		HEX6,
	output		     [6:0]		HEX7,

	//////////// LCD //////////
	output		          		LCD_BLON,
	inout 		     [7:0]		LCD_DATA,
	output		          		LCD_EN,
	output		          		LCD_ON,
	output		          		LCD_RS,
	output		          		LCD_RW,

	//////////// RS232 //////////
	input 		          		UART_CTS,
	output		          		UART_RTS,
	input 		          		UART_RXD,
	output		          		UART_TXD,

	//////////// PS2 for Keyboard and Mouse //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [31:0]		DRAM_DQ,
	output		     [3:0]		DRAM_DQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_WE_N,

	//////////// Flash //////////
	output		    [22:0]		FL_ADDR,
	output		          		FL_CE_N,
	inout 		     [7:0]		FL_DQ,
	output		          		FL_OE_N,
	output		          		FL_RST_N,
	input 		          		FL_RY,
	output		          		FL_WE_N,
	output		          		FL_WP_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire CLOCK_25M;
wire move;
reg [7:0]dataOut;
wire [8:0]dataOut1;
wire [7:0]dataOut2;
wire enInit;
wire enLine;
wire lineDone;
wire initDone;
wire start;
wire dc;
wire clkHold;
wire dataHold;
wire spiData;
wire spiClk;
wire idle;
wire [18:0]colorCount;
reg [15:0]color;
wire [7:0]x1, x2;
wire [8:0]y1, y2;

wire shiftRegEn;
wire [7:0] keyboardData;
wire data_en;
wire [9:0] decodedData;
wire done;
wire [3:0] keyDir;
wire [3:0] touchDir;
wire [3:0] dir;
wire walking;

///////////////////////////
// Touch Screen 
///////////////////////////
wire Touch_Div_Clk, Touch_En, X_Touch, Y_Touch;
wire [7:0] Data_Wire_Touch;
wire [7:0] X_Latch, Y_Latch;

///////////////////////////
// LSFR wires
///////////////////////////
wire [19:0]random;
wire [19:0]randOut;

//=======================================================
//  Structural coding
//=======================================================
assign GPIO[3] = dataOut1[8] | dc;
assign GPIO[7] = idle ?  1'b1 : (spiClk | ~clkHold);
//assign GPIO[1] = idle ?  1'b1 : (spiData | dataHold);
assign LEDG[0] = lineDone;
assign LEDG[1] = initDone;

assign dir[0] = (keyDir[0] | touchDir[0]);
assign dir[1] = (keyDir[1] | touchDir[1]);
assign dir[2] = (keyDir[2] | touchDir[2]);
assign dir[3] = (keyDir[3] | touchDir[3]);

assign LEDR[3:0] = dir;

always @ (*)
	if (enInit) 
		if (dataHold)
			dataOut = 8'hFF;
		else
			dataOut = dataOut2;
	else if (enLine)
		dataOut = dataOut1[7:0];
	else
		dataOut = 8'hFF;

PLL	PLL_inst (
	.inclk0 ( CLOCK2_50 ),
	.c0 (CLOCK_25M)
);

////////////////////////////////////
//	LCD Modules
////////////////////////////////////
Sprite_Controller u0(
		.colorCount(colorCount[18:1]),
		.dir(dir),
		.canvas(SW[1]),
		.clk(CLOCK_25M),
		.x1(x1), 
		.x2(x2),
		.y1(y1), 
		.y2(y2),
		.walkSig(walking),
		.colorOut(color)
);

LCDController u1 (
				.goInit(~KEY[0]),
				.goLine((|dir)),
				.doneLine(lineDone),
				.doneInit(initDone),
				.clk(CLOCK_25M),
				.enLine(enLine),
				.enInit(enInit),
				.idle(idle)
);

sendByteSPI u2(
				.clk( CLOCK_25M ),
				.go(~lineDone | ~initDone),
				.done(move),
				.dIn(dataOut),
				.clkOut(spiClk),
				.dOut(GPIO[5])
);

init u3	(
				.resetOut(GPIO[1]),
				.move(move & enInit),
				.done(initDone),
				.dc(dc),
				.clkHold(clkHold),
				.dataHold(dataHold),
				.dOut(dataOut2)
);


DrawLine u4 (
				.move(move & enLine),
				.x1(x1), 	//start X
				.x2(x2),	 	//end X
				.y1(y1), 		//start Y
				.y2(y2),		//end Y
				.color(color),	//Color being displayed
				.done(lineDone),
				.dout(dataOut1),
				.colorCount(colorCount)
);

////////////////////////////////////
//	Keyboard Modules
////////////////////////////////////
State_Machine u10 (
	.clk (PS2_CLK),	// keyboard clock
	.en (shiftRegEn),
	.done(done)
);	// enable shift register to start collecting data

Shift_Reg u11 (
	 .en (shiftRegEn),	// start collecting data
	 .data (PS2_DAT),	// serial keyboard data
	 .clk (PS2_CLK),	// keyboard clock
	 .data_reg (keyboardData));	// 8 bit output data
	 
decoder u12 (
	.PS2_Value (keyboardData),	// 8 bit data from shift register
	.data_en (data_en),	// enable line for LCD control - could potentially use
	.enable (shiftRegEn),	// negedge enable
	.ASCII (decodedData));	// 10 bit output data
	
Key_Controller u13(
	.done(done),
	.ASCII (decodedData),
	.leftOut (keyDir[2]),
	.rightOut (keyDir[3]), 
	.upOut (keyDir[0]), 
	.downOut (keyDir[1]));
	
////////////////////////////////////
//	Touch Modules
////////////////////////////////////
assign GPIO [33] = Touch_Div_Clk;	// touch clock

Clock_Div_Touch u20 (
	.clk (CLOCK_50),		// 50MHZ
	.div_clk (Touch_Div_Clk));	// 1Mhz 
	
	
TFT_Touch_Controller u21 (
	.Dout (GPIO[35]),	// TDIN (output)
	.en (Touch_En),	// data ready
	.x (X_Touch),		// got x data
	.y (Y_Touch),		// got y data
	.clk (Touch_Div_Clk));
	
Shift_Reg_Touch u22 (
	.en (Touch_En),	// start shifting in data
	.data (GPIO[34]),	// TDOUT (input)
	.clk (Touch_Div_Clk),
	.data_reg (Data_Wire_Touch));	// 8 bit output of shifted in data
	
	
LED_Controller_Touch u23(
	.x_hold (X_Latch),
	.y_hold (Y_Latch),
	.right_button (touchDir[3]),
	.left_button (touchDir[2]),
	.down_button (touchDir[1]),
	.up_button (touchDir[0]));
	
TFT_Touch_Latch u24(
	.x_hold (X_Latch), 
	.y_hold (Y_Latch),
	.data (Data_Wire_Touch),

	.x (X_Touch),
	.y (Y_Touch));
	
//////////////////////////////
// LSFR Modules
//////////////////////////////
assign LEDG[8] = (randOut > 996146)? 0 : 1; //10% chance

rngGenerator u31 (
			.clk(CLOCK_50),
			.en(1),
			.load(SW[17]),
			.seed(SW[16:0]),
			.dataOut(random)
);

pollREG u32 (
			.en(walking),
			.dataIn(random),
			.dataOut(randOut)
);

endmodule
